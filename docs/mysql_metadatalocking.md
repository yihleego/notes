# Metadata Locking

元数据锁用来管理对数据库对象的并发访问并确保数据一致性。元数据锁定不仅适用于表，还适用于库、存储程序（过程、函数、触发器、计划事件）、表空间等。

|     | 写锁  | 读锁  |
|:---:|:---:|:---:|
| 写锁  | 冲突  | 冲突  |
| 读锁  | 冲突  | 兼容  |

假设存在以下操作：

|     | Session 1          | Session 2          | Session 3                    | Session 4          | 
|:----|:-------------------|:-------------------|:-----------------------------|:-------------------|
| 1   | begin;             |                    |                              |                    |  
| 2   | select * from foo; |                    |                              |                    | 
| 3   |                    | select * from foo; |                              |                    | 
| 4   |                    |                    | alter table foo add bar int; |                    |
| 5   |                    |                    |                              | select * from foo; | 
| 6   | commit;            |                    |                              |                    | 

1. `Session 1`开启事务。
2. `Session 1`执行查询前获取`MDL`读锁，查询完成后未提交事务。
3. `Session 2`执行查询前获取`MDL`读锁，由于`MDL`读锁不互斥，因此执行成功。
4. `Session 3`对表结构进行修改前，需要获得`MDL`写锁，但是由于`Session 1`持有了`MDL`读锁，因此当前会话被阻塞。
5. `Session 4`执行查询前获取`MDL`读锁，由于获取锁是有先后顺序的，所以当前会话被`Session 3`被阻塞。
6. `Session 1`提交事务，`Session 4`可能会比`Session 3`提前执行完。

第六步中，`Session 4`可能会比`Session 3`提前执行完，其实涉及到`Online DDL`的知识，大致流程如下：

1. 获取`MDL`写锁：创建临时的`frm`和`ibd`文件，由于这个过程需要保证安全，因此是排他的，同时这个过程也是快速的。
2. 降级成`MDL`读锁：临时文件创建完成之后，于是不需要排他，就降级为读锁，支持增删改查。
3. 执行DDL：写入数据。
4. 升级成`MDL`写锁：替换数据文件，由于这个过程需要保证安全，因此会尝试升级成`MDL`写锁，这个过程也是快速的。
5. 释放`MDL`锁。

第1步、第2步、第4步和第5步执行时间较短，第3步占了绝大部分时间，而这个期间，表可以进行正常读写，所以被称为`Online DDL`。

由此可得，`Session 3`将`MDL`写锁降级为读锁后，`Session 4`就可以获取`MDL`读锁并完成查询。
