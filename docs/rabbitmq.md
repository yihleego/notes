# RabbitMQ

RabbitMQ 是一个基于 Erlang 开发的，实现了高级消息队列协议（AMQP）的，开源的消息中间件。

## 主要角色

### Broker

Broker 主要负责消息存储、消息分发和消息投递。

### Virtual Host

Virtual Host 是 AMQP 概念的基础，每个 Broker 可以包含一个或多个 Virtual Host ，每个 Virtual Host 拥有自己的队列、交换器、绑定和权限机制。

### Publisher

消息生产者，直接将消息发送到交换器，通过交换器将消息路由到一个或者多个队列中。当路由失败时，返回给生产者或直接丢弃。

### Consumer

消息消费者，连接至 RabbitMQ 服务器并订阅到队列上。

## 核心组件

### Message

Message 是消息载体，由消息体和消息头组成。消息体即为消息本身内容，消息头可以对消息进行修饰，例如，优先级、延迟等特性。

### Queue

Queue 是消息队列，用于储存消息的容器，每个消息都会被存放到一个或多个队列中，等待消费者连接到队列并进行消费。

### Exchange

Queue 是消息交换器，用于接收生产者发送的消息，然后根据 Routing Key 将消息转发到绑定的 Queue。

三种常见的交换器类型：

- Direct：通过 Routing Key 将消息路由到完全匹配的队列。
- Topic：通过 Routing Key 匹配规则将消息路由到对应的队列，通常使用`.`作为字符串分隔符，使用`*`和`#`模糊匹配，`*`匹配一个单词，`#`匹配零个或多个。
- Fanout：忽略 Routing Key，把所有消息发送到该交换器绑定的队列。

### Routing Key

Routing Key 是消息路由键，Virtual Host 可用它来确定如何路由一个特定消息，Exchange 会通过它将消息转发到绑定的 Queue。
生产者发送消息时，该消息会附带一个 Routing Key，即便是空的，Exchange 也会将其和绑定使用的路由键进行匹配。如果匹配，消息将投递到绑定的队列；如果不匹配，消息将会进入黑洞。
当一个 Routing Key 绑定的 Exchange 对应多个 Queue 时，会将消息扩散转发到这些 Queue 中，会导致不同 Queue 的中存在相同的消息。

### Binding

Binding 通过一个 Routing Key 将 Exchange 和 Queue 进行绑定。

## 高可用

### 普通集群模式

通过启动多个 RabbitMQ 节点，每个节点相互同步元数据，但是消息只存在它所创建的节点上。
通过元数据，当消费者向一个节点获取消息，发现该消息存在于另一个节点上时，则会先去另一个节点上拉取该消息，然后再转发给消费者。

由于采用的是转发模式而不是同步模式，所以当其中一个节点不可用时，进而会影响相关的消费者。

### 镜像集群模式

跟普通集群模式不一样的是，在镜像集群模式下，队里中的消息和元数据都会存在于多个节点上，就是说，每个 RabbitMQ 节点都有一个 Queue 的完整镜像，包含全部数据。
生产者每次发送消息时，都会自动把消息同步到各个节点中。

如果一个节点不可用时，其他节点包含了该节点的消息，就可以保证消费者可以继续消费。缺点也很明显，消息需要同步到所有机器上，会占用网络带宽，而且需要额外的空间，空间利用率不高。

## 消息重复消费

消息队列无法保证消息不被重复消费，需要通过业务代码实现幂等。

## 消息可靠投递

### 从 Broker 端考虑

1. 创建 Queue 的时候将其设置为持久化，可以保证 RabbitMQ 持久化 Queue 的元数据。
2. 发送消息的时候将消息的 deliveryMode 设置为 2。就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。

### 从 Producer 端考虑

1. 采用同步发送方式，发送一条消息并等待返回响应结果，如果返回结果为失败，则可以重试或抛出业务异常。
    - 发送成功，说明消息已经投递
    - 发送失败，可以重试或抛出异常
    - 发送超时，可以通过通过查询日志判断是否已经投递
2. 采用事务消息的投递方式。

### 从 Consumer 端考虑

1. 保证业务处理完成后再返回 ACK，如果消费者在处理过程中发生崩溃故障，RabbitMQ 会将消息分配给别的消费者去处理。

## 消息顺序消费

将一个大 Queue 拆分成多个小 Queue，每一个小 Queue 对应一个唯一的 Consumer 进行消费。

## 延迟队列

- RabbitMQ 3.6 及以前的版本，只能通过死信队列实现，发送消息时设置存活时间，消息过期后会被投入死信队列。
- RabbitMQ 3.7 及之后的版本，可以使用[rabbitmq-delayed-message-exchange](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange)插件实现延迟队列。