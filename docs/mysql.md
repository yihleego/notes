# MySQL

## 索引结构

为什么默认的存储引擎选择`B+Tree`而不是`Hash`或者`B-Tree`的原因：

- `Hash`虽然能够提供`O(1)`的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描。
- `B-Tree`能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而`B+Tree`的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O。

## InnoDB Locking

- 共享/排它锁 （Shared and Exclusive Locks）
- 意向锁 （Intention Locks）
- 记录锁 （Record Locks）
- 间隙锁 （Gap Locks）
- 临键锁 （Next-Key Locks）
- 插入意向锁 （Insert Intention Locks）
- 自增锁 （AUTO-INC Locks）
- 空间索引谓词锁 （Predicate Locks for Spatial Indexes）

### 共享/排它锁

InnoDB实现标准的行级锁定，其中有两种类型的锁：

- 共享锁（S）：允许持有该锁的事务读取一行。
- 排它锁（X）：允许持有该锁的事务更新或删除一行。

如果一个事务`T1`持有行`r`上的一个共享(S)锁，那么来自不同事务T2的请求对行`r`上的一个锁处理如下:

- 可以立即授予`T2`对(S)锁的请求，因此，`T1`和`T2`都对行`r`保持(S)锁定。
- 不能立即授予`T2`对(X)锁的请求。

如果事务`T1`在行`r`上持有排他(X)锁，则无法立即授予来自某个不同事务`T2`对`r`上任一类型的锁的请求。相反，事务`T2`必须等待事务`T1`释放其对行`r`的锁定。

|     |  X   |  S   |
|:---:|:----:|:----:|
|  X  |  冲突  |  冲突  |
|  S  |  冲突  |  兼容  |

### 意向锁

InnoDB 支持多粒度锁，允许行锁和表锁共存。例如：`LOCK TABLES ... WRITE`之类的语句在指定表上采用排他(X)锁。为了使多粒度级别的锁定变得实用，InnoDB 使用意图锁。意向锁是表级锁，它指示事务稍后对表中的行需要哪种类型的锁（共享或独占）。有两种类型的意图锁：

- 意向共享锁（IS）：事务想要获得一张表中某几行的共享锁。
- 意向排它锁（IX）：事务想要获得一张表中某几行的排它锁。

意向锁规则如下：

在事务可以获取表中行的共享(S)锁之前，它必须首先获取表上的(IS)锁或更重的锁。

在事务可以获取表中行的排他(S)锁之前，它必须首先获取表上的(IX)锁。

除了全表请求（例如：`LOCK TABLES ... WRITE`）之外，意图锁不会阻塞任何东西。意图锁的主要目的是表明有人正在锁定一行，或者要锁定表中的一行。

设置(IS)锁：`SELECT ... FOR SHARE`

设置(IX)锁：`SELECT ... FOR UPDATE`

注意，`FOR SHARE`是`LOCK IN SHARE MODE`的替代品，但`LOCK IN SHARE MODE`仍可用于向后兼容。

|     |  X   |  IX  |  S   |  IS  |
|:---:|:----:|:----:|:----:|:----:|
|  X  |  冲突  |  冲突  |  冲突  |  冲突  |
| IX  |  冲突  |  兼容  |  冲突  |  兼容  |
|  S  |  冲突  |  冲突  |  兼容  |  兼容  |
| IS  |  冲突  |  兼容  |  兼容  |  兼容  |

### 记录锁

记录锁是对索引记录的锁。例如：`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE`，防止任何其他事务插入、更新或删除`t.c1`值为`10`的行。

### 间隙锁

间隙锁是在索引记录之间的间隙上的锁，或在第一条索引记录之前或最后一条索引记录之后的间隙上的锁。例如：`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE`，防止其他事务将值`15`插入`t.c1`列，无论该列中是否已经存在任何此类值，因为该范围内所有现有值之间的间隙都已锁定。

间隙可能跨越单个索引值、多个索引值，甚至是空的。

InnoDB 中的间隙锁是“纯粹的抑制性”，这意味着它们的唯一目的是防止其他事务插入到间隙中。间隙锁可以共存。一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。共享和独占间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。

间隙锁定可以被显式禁用。如果您将事务隔离级别更改为`READ COMMITTED`，则会发生这种情况。在这种情况下，间隙锁定对搜索和索引扫描禁用，仅用于外键约束检查和重复键检查。

### 临键锁

临键锁是记录锁和间隙锁的组合。

假设存在以下表及数据：

```mysql
create table `test`
(
    `id` int primary key auto_increment,
    `v`  int,
    key `v` (`v`)
) engine = InnoDB;
```

其中`id`列为自增主键，并为`v`列创建了索引。

| id  | v   |
|:----|:----|
| 10  | 1   |
| 11  | 3   | 
| 12  | 5   | 
| 13  | 8   | 
| 14  | 11  | 
| 15  | 13  | 

该索引可能的临键锁涵盖以下区间：

```text
(-∞, 1]
(1, 3]
(3, 5]
(5, 8]
(8, 11]
(11, 13]
(13, +∞)
```

当我们开启事务`T1`执行以下`SQL`时，保持事务不提交，会锁住`(5, 8]`和`(8, 11]`区间。

```mysql
start transaction;
select * from test where v = 8 for update;
```

所以我们可以预测在新的事务`T2`中分别执行以下`SQL`的结果：

```mysql
insert into test(v) values(1);  // 区间外 预测：non-blocking 实际：non-blocking 符合预期
insert into test(v) values(4);  // 区间外 预测：non-blocking 实际：non-blocking 符合预期
insert into test(v) values(5);  // 区间外 预测：non-blocking 实际：blocking     不符合预期
insert into test(v) values(9);  // 区间内 预测：blocking     实际：blocking     符合预期
insert into test(v) values(11); // 区间内 预测：blocking     实际：non-blocking 不符合预期
insert into test(v) values(12); // 区间外 预测：non-blocking 实际：non-blocking 符合预期
```

根据临键锁的区间，我们预测在`T2`事务中分别插入值为`9`和`11`的数据会被`T1`事务阻塞。 但是实际上在插入值为`5`和`9`时才会被阻塞，结果并不符合预期，似乎违背了临键锁的设计，这就要从索引结构（B+tree）说起了。

是由于 InnoDB 的叶子节点都是按顺序的插入的，并且`id`为自增主键，因此我们插入值为`5`的记录时，会将数据追加到原来值为`5`数据的后面，于是就落到了`T1`事务临键锁涵盖的区间内。同理可知插入值为`11`的记录时，实际的叶子节点在区间外。

![mysql_nextkeylocks_btree](images/mysql_nextkeylocks_btree.png)

### 插入意向锁

插入意向锁是由`INSERT`操作设置的一种特殊的间隙锁，而并非是上述提到的意向锁，意向锁是表级锁，而插入意向锁是行级锁。

此锁表示插入的意图，即如果插入到同一索引间隙中的多个事务未插入到间隙内的同一位置，则它们无需相互等待。 假设有值为 4 和 7 的索引记录。分别尝试插入值 5 和 6 的单独事务，在获得插入行的排他锁之前，每个使用插入意图锁锁定 4 和 7 之间的间隙，但不要相互阻塞，因为行是不冲突的。

### 自增锁

自增锁是一种特殊的表级锁，由插入到具有`AUTO_INCREMENT`列的表中的事务使用。 在最简单的情况下，如果一个事务正在向表中插入值，则任何其他事务都必须等待在该表中执行自己的插入操作，以便第一个事务插入的行接收连续的主键值。

### 空间索引谓词锁

_忽略_

## Metadata Locking

元数据锁用来管理对数据库对象的并发访问并确保数据一致性。元数据锁定不仅适用于表，还适用于库、存储程序（过程、函数、触发器、计划事件）、表空间等。

|     | 写锁  | 读锁  |
|:---:|:---:|:---:|
| 写锁  | 冲突  | 冲突  |
| 读锁  | 冲突  | 兼容  |

假设存在以下操作：

|     | Session 1          | Session 2          | Session 3                    | Session 4          | 
|:----|:-------------------|:-------------------|:-----------------------------|:-------------------|
| 1   | begin;             |                    |                              |                    |  
| 2   | select * from foo; |                    |                              |                    | 
| 3   |                    | select * from foo; |                              |                    | 
| 4   |                    |                    | alter table foo add bar int; |                    |
| 5   |                    |                    |                              | select * from foo; | 
| 6   | commit;            |                    |                              |                    | 

1. `Session 1`开启事务。
2. `Session 1`执行查询前获取`MDL`读锁，查询完成后未提交事务。
3. `Session 2`执行查询前获取`MDL`读锁，由于`MDL`读锁不互斥，因此执行成功。
4. `Session 3`对表结构进行修改前，需要获得`MDL`写锁，但是由于`Session 1`持有了`MDL`读锁，因此当前会话被阻塞。
5. `Session 4`执行查询前获取`MDL`读锁，由于获取锁是有先后顺序的，所以当前会话被`Session 3`被阻塞。
6. `Session 1`提交事务，`Session 4`可能会比`Session 3`提前执行完。

第六步中，`Session 4`可能会比`Session 3`提前执行完，其实涉及到`Online DDL`的知识，大致流程如下：

1. 获取`MDL`写锁：创建临时的`frm`和`ibd`文件，由于这个过程需要保证安全，因此是排他的，同时这个过程也是快速的。
2. 降级成`MDL`读锁：临时文件创建完成之后，于是不需要排他，就降级为读锁，支持增删改查。
3. 执行DDL：写入数据。
4. 升级成`MDL`写锁：替换数据文件，由于这个过程需要保证安全，因此会尝试升级成`MDL`写锁，这个过程也是快速的。
5. 释放`MDL`锁。

第1步、第2步、第4步和第5步执行时间较短，第3步占了绝大部分时间，而这个期间，表可以进行正常读写，所以被称为`Online DDL`。

由此可得，`Session 3`将`MDL`写锁降级为读锁后，`Session 4`就可以获取`MDL`读锁并完成查询。

## 事务的基本特性和隔离级别

### ACID

是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（Transaction）是正确可靠的，所必须具备的四个特性：

- 原子性（Atomicity）：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态。
- 一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
- 隔离性（Isolation）：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 持久性（Durability）：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

### 并发事务处理带来的问题

- 更新丢失（Lost Update）：事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题。
- 脏读（Dirty Reads）：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。
- 不可重复读（Non-Repeatable Reads）：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
- 幻读（Phantom Reads）：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。

“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：

- 加锁（Locking）：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
- 多版本并发控制（MultiVersion Concurrency Control，简称 MVCC）：不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。

### 隔离级别

数据库事务的隔离级别有4种，由低到高分别为

- 读未提交（READ-UNCOMMITTED）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- 读已提交（READ-COMMITTED）：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- 可重复读（REPEATABLE-READ）：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- 可串行化（SERIALIZABLE）：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

查看当前数据库的事务隔离级别：`show variables like 'transaction_isolation'`

### 多版本并发控制

InnoDB中通过Undo Log实现了数据的多版本，而并发控制通过锁来实现。

InnoDB行记录中有两个隐藏字段`trx_id`和`db_roll_ptr`，`trx_id`表示最近修改的事务的`id`，`db_roll_ptr`指向Undo Segment中的Undo Log。

_MVCC 只在读已提交（READ-COMMITTED）和可重复读（REPEATABLE-READ）两种隔离级别下工作。_

### Redo Log

Redo Log记录了数据操作在物理层面的修改，MySQL中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘。

当内存和磁盘的数据不一致时，称内存中的数据为脏页(Dirty Page)。为了保证数据的安全性，事务进行中时会不断的产生Redo Log，在事务提交时进行一次flush操作时保存到磁盘中。

Redo Log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据Redo Log进行数据的恢复，如果Redo Log中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性。

### Undo Log

除了记录Redo Log外，当进行数据修改时还会记录Undo Log。

Undo Log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过Undo Log可以实现事务回滚，并且可以根据Undo Log回溯到某个特定的版本的数据，实现MVCC。

### Binary Log

Binary Log，是MySQL服务层产生的日志，常用来进行数据恢复、数据库复制，常见的MySQL主从架构，就是采用slave同步master的Binary Log实现的, 另外通过解析Binary Log能够实现MySQL到其他数据源的数据复制，如：Elasticsearch、Redis等。

## Q&A

### MyISAM和InnoDB的区别

- MyISAM是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于有大量查询少量插入的场景来使用，而且MyISAM不支持外键，并且索引和数据是分开存储的，虽然也是B+Tree。
- InnoDB是基于聚簇索引建立的，和MyISAM相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。
- Memory存储引擎：不会在磁盘上创建任何文件，表定义存储在 MySQL 数据字典中，表的数据存储在内存中，支持Hash索引。

### InnoDB聚簇索引和非聚簇索引

B-Tree是左小右大的顺序存储结构，节点只包含主键索引列，而叶子节点包含索引列和数据，这种数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引。

假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。

非聚簇索引只包含索引对应字段的值和主键的值。

### 覆盖索引和回表

覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。

而要确定一个查询是否是覆盖索引，我们只需要`EXPLAIN`语句看`Extra`的结果是否是`Using index`即可。

### 分库分表

### 读写分离/主从同步