# Business

## 秒杀

秒杀特点是短时间内，大量用户涌入，集中读和写有限的库存。

层层拦截，将请求尽量拦截在系统上游，避免将锁冲落到数据库上。

### 第一层：客户端优化

产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求； JS层面，限制用户在x秒之内只能提交一次请求，比如微信摇一摇抢红包。 基本可以拦截80%的请求。

### 第二层：网关层拦截

怎么防止程序员写for循环调用，有去重依据么? IP? cookie-id? …想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单，比如guava本地缓存）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。

对于5s内的无效请求，统一返回错误提示或错误页面。 这个方式拦住了写for循环发HTTP请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。

参考：令牌桶（Spring Cloud Gateway）、时间窗口（Sentinel）

### 第三层：服务层拦截

方案一：写请求放到队列中，每次只透有限的写请求到数据层，如果成功了再放下一批，直到库存不够，队列里的写请求全部返回“已售完”。

方案二：或采用漏斗机制，只放一倍的流量进来，多余的返回“已售完”，把写压力转换成读压力。 读请求，用cache，redis单机可以抗10W QPS,用异步线程定时更新缓存里的库存值。

还有提示“模糊化”，比如火车余票查询，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票。

### 第四层：数据库层

浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。 db基本就没什么压力了，通过自身锁机制来控制，避免出现超卖。

## 订单

SPU

SKU

生成订单号后，将订单号放入缓存，直接返回给客户端，客户端轮询订单状态，服务端异步处理创建订单，扣减库存等操作。

## 支付

生成交易流水记录后，直接返回给客户端，客户端轮询，异步拉起收银台

## 灰度

网关

服务路由

MQ 路由

线程池问题

## 海量数据

分而治之

## 即时通信

Chat API

Chat Server

## 权限系统

### Role-Based Access Control

RBAC通常应用于组织、部门、群组、角色、岗位等不同授权方式，通常包括RBAC0、RBAC1、RBAC2和RBAC3四种模型。

- RBAC0：权限最基础也是最核心的模型, 它包括用户 / 角色 / 权限, 其中用户和角色是多对多的关系, 角色和权限也是多对多的关系。
- RBAC1: 此模型引入了角色继承 (Hierarchical Role) 概念，即角色具有上下级的关系，角色间的继承关系可分为一般继承关系和受限继承关系。
- RBAC2: 基于核心模型的基础上，进行了角色的约束控制，RBAC2 模型中添加了责任分离关系。其规定了权限被赋予角色时，或角色被赋予用户时，以及当用户在某一时刻激活一个角色时所应遵循的强制性规则。责任分离包括静态责任分离和动态责任分离。
- RBAC3: 即最全面的权限管理, 它是基于 RBAC0，将 RBAC1 和 RBAC2 进行了整合。

![access_control_rbac.png](images/access_control_rbac.png)

在大型的企业应用中，通常是根据不同的工作岗位来设置，例如Manager、Employee等。每个角色被赋予一组权限，可以针对不同的资源进行某些操作。用户通常不会被直接赋予权限，而是通过分配不同的角色从而获得相应的权限。

#### 组件

- 权限=资源+操作
    - 功能权限
        - 页面权限/菜单权限
        - 按钮权限
    - 数据权限
        - 查看权限
        - 字段权限
- 授权
- 角色
- 权限包（拓展）
- 职位（拓展）

### Attribute-Based Access Control

ABAC基于策略进行访问控制，即对RBAC的环境策略和行为策略进行进一步权限控制，每一条策略可以使用任何属性来定义。

通常来说，有三种类型的属性：Subject的属性、Resource的属性和系统属性。例如每个员工有一个属性“类型”，而每一个业务系统也有一个属性“部门”，
那么就可以定义一个策略，只有某个正式员工与业务系统允许访问的部门符合，那么这个员工就可以查看业务系统的具体某个业务单元。

![access_control_abac.png](images/access_control_abac.png)

### RBAC 与 ABAC 的区别

RBAC一般用于粗粒度的权限控制，而ABAC则用于细粒度的权限控制。例如只要是企业正式员工都可以访问培训学习系统，那么使用RBAC足以。
如果再加一条限制，任何正式员工只要在过去半年内未完成培训课程目标，那么不能学习新课程，那么就要用ABAC来控制。
通常来说，应该尽量优先使用RBAC，然后再考虑使用ABAC，但通常会将两者结合起来使用。在实际的应用中，很自然的就可以将实际的各种角色（例如员工、外包用户等）映射成RBAC中的Role，所以RBAC让人比较容易接受。
而另一方面，RBAC灵活性上的欠缺，所以需要借助于ABAC来处理各种特殊权限控制的需要。

RBAC价值主要体现在减少授权管理的复杂性、降低管理开销、灵活的支持企业的安全策略和对企业的变化有很大的伸缩性；ABAC因其灵活的授权方式，通常面向跨组织边界进行复杂的细粒度权限管理和管控。

## 分布式ID

### UUID

- 优点：使用简单，不依赖其他库，本地生成没有网络消耗，几乎不会发生碰撞
- 缺点：字符串太长，不易于存储，基于MAC地址生成UUID的算法可能会造成MAC地址泄露，对数据库索引不利

### Snowflake

- 优点：使用简单，不依赖其他库，趋势递增，性能好，几乎不会发生碰撞
- 缺点：强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复

### Bson ObjectId

- 优点：使用简单，不依赖其他库，性能好，几乎不会发生碰撞
- 缺点：字符串太长，不易于存储，对数据库索引不利

### 基于 Redis

- 优点：有序递增，性能好
- 缺点：引入复杂度，数据持久化丢失问题

### 基于数据库批量获取ID

- 优点：有序递增
- 缺点：性能一般（可以通过批量获取一段ID，但是会导致非严格有序）

## 短链

1. 申请一个短域名
2. 通过 MurmurHash 将 URL 转化为哈希值，然后将其作为 Key，URL 为 Value 保存到 Redis 中
3. Nginx/OpenResty 通过 lua 脚本从 Redis 中获取对应的 URL，然后 301/302 重定向。
    - 301: Permanently moved 永久性转移
    - 302: Temporarily moved 暂时性转移

Guava:

```java
Hashing.murmur3_32_fixed().hashUnencodedChars(url)
```

## 任务调度

HTTP通信、TCP通信

### 服务端集群

- 维护任务相关信息
- 动态启用任务
- 通过分布式锁控制并发
- 注册中心或配置服务
- 任务中断
- 任务依赖
- 任务互斥
- 服务优雅下线

### 客户端集群

- 分片处理
- 保存日志（重试）
- 封装
- 文档
- 降低开发者心智负担

## 分布式事务

- 分布式事务解决方案 Seata
- 补偿机制

## 服务治理

- 服务注册发现
- 服务负载均衡
- 服务熔断
- 服务降级
- 服务限流
- 服务依赖关系
- 服务通信（Rest、RPC、MQ）
- 服务文档
- 服务安全
- 服务上线，下线的流程
- 服务编排
- 配置管理
- 自动化测试
- 兼容性
- 资源调度
- 容量规划
